<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DM42 Drill System - Algebra 2 & AP Stats Unit 3</title>
    <style>
        :root {
            --primary: #2c3e50;
            --primary-light: #34495e;
            --accent: #3498db;
            --accent-hover: #2980b9;
            --success: #27ae60;
            --error: #c0392b;
            --bg: #f8f9fa;
            --card-bg: #ffffff;
            --text: #2c3e50;
            --text-muted: #7f8c8d;
            --border: #dce1e4;
            --key-bg: #1a1a2e;
            --key-text: #e8e8e8;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: var(--primary);
            color: white;
            padding: 20px;
            margin-bottom: 24px;
            border-radius: 8px;
        }

        header h1 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 4px;
        }

        header .subtitle {
            font-size: 0.9rem;
            opacity: 0.85;
        }

        .stats-bar {
            display: flex;
            gap: 24px;
            margin-top: 12px;
            font-size: 0.85rem;
        }

        .stat {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .stat-value {
            font-weight: 600;
            color: var(--accent);
        }

        /* Category Tabs */
        .category-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 20px;
        }

        .tab-btn {
            padding: 10px 16px;
            border: 2px solid var(--border);
            background: var(--card-bg);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text);
            transition: all 0.2s;
        }

        .tab-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .tab-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .tab-btn .tab-progress {
            font-size: 0.75rem;
            opacity: 0.7;
            margin-left: 6px;
        }

        /* Main Card */
        .drill-card {
            background: var(--card-bg);
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            padding: 28px;
            margin-bottom: 20px;
        }

        .category-title {
            font-size: 1.1rem;
            color: var(--text-muted);
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border);
        }

        .question-area {
            margin-bottom: 24px;
        }

        .question-label {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .question-text {
            font-size: 1.25rem;
            font-weight: 500;
            line-height: 1.5;
        }

        .question-text .math {
            font-family: 'Times New Roman', Times, serif;
            font-style: italic;
        }

        .polynomial {
            font-family: 'Times New Roman', Times, serif;
            font-size: 1.3rem;
        }

        sup {
            font-size: 0.7em;
            vertical-align: super;
        }

        /* Answer Input */
        .answer-section {
            margin-bottom: 24px;
        }

        .answer-row {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        .answer-input {
            flex: 1;
            min-width: 200px;
            padding: 12px 16px;
            font-size: 1.1rem;
            border: 2px solid var(--border);
            border-radius: 6px;
            outline: none;
            transition: border-color 0.2s;
        }

        .answer-input:focus {
            border-color: var(--accent);
        }

        .answer-input.correct {
            border-color: var(--success);
            background: #f0fff4;
        }

        .answer-input.incorrect {
            border-color: var(--error);
            background: #fff5f5;
        }

        .btn {
            padding: 12px 24px;
            font-size: 1rem;
            font-weight: 500;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--accent);
            color: white;
        }

        .btn-primary:hover {
            background: var(--accent-hover);
        }

        .btn-secondary {
            background: var(--primary-light);
            color: white;
        }

        .btn-secondary:hover {
            background: var(--primary);
        }

        .feedback {
            margin-top: 12px;
            padding: 12px 16px;
            border-radius: 6px;
            font-weight: 500;
            display: none;
        }

        .feedback.correct {
            display: block;
            background: #d4edda;
            color: #155724;
        }

        .feedback.incorrect {
            display: block;
            background: #f8d7da;
            color: #721c24;
        }

        /* Expandable Sections */
        .expandable {
            margin-top: 16px;
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
        }

        .expandable-header {
            padding: 14px 18px;
            background: #f8f9fa;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 500;
            user-select: none;
        }

        .expandable-header:hover {
            background: #eef1f3;
        }

        .expandable-arrow {
            transition: transform 0.2s;
        }

        .expandable.open .expandable-arrow {
            transform: rotate(180deg);
        }

        .expandable-content {
            display: none;
            padding: 18px;
            border-top: 1px solid var(--border);
        }

        .expandable.open .expandable-content {
            display: block;
        }

        /* Keystroke Display */
        .keystroke-step {
            margin-bottom: 16px;
        }

        .keystroke-step:last-child {
            margin-bottom: 0;
        }

        .step-label {
            font-size: 0.9rem;
            color: var(--text-muted);
            margin-bottom: 6px;
        }

        .keystroke-box {
            background: var(--key-bg);
            color: var(--key-text);
            font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
            padding: 12px 16px;
            border-radius: 6px;
            font-size: 1rem;
            letter-spacing: 0.5px;
            border: 1px solid #333;
        }

        .key {
            display: inline-block;
            background: #2d2d44;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 2px 8px;
            margin: 0 2px;
            font-size: 0.9em;
        }

        .key-shift {
            background: #4a4a6a;
            color: #ffd700;
        }

        .key-enter {
            background: #2e5a2e;
        }

        .keystroke-comment {
            color: #888;
            font-style: italic;
            margin-left: 8px;
        }

        /* Solution Section */
        .solution-text {
            font-size: 1rem;
            line-height: 1.8;
        }

        .solution-step {
            margin-bottom: 8px;
        }

        .solution-answer {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--success);
            margin-top: 12px;
        }

        /* Action Buttons */
        .action-buttons {
            display: flex;
            gap: 12px;
            margin-top: 24px;
            padding-top: 20px;
            border-top: 1px solid var(--border);
        }

        /* Progress Card */
        .progress-card {
            background: var(--card-bg);
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            padding: 20px;
        }

        .progress-title {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 16px;
        }

        .progress-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
        }

        .progress-item {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 6px;
            text-align: center;
        }

        .progress-item-label {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        .progress-item-value {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--primary);
        }

        .progress-bar-container {
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            margin-top: 8px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: var(--accent);
            border-radius: 3px;
            transition: width 0.3s;
        }

        /* Random Drill Special */
        .random-results {
            background: #f8f9fa;
            padding: 16px;
            border-radius: 6px;
            margin-top: 16px;
        }

        .random-number {
            display: inline-block;
            background: var(--primary);
            color: white;
            padding: 6px 12px;
            margin: 4px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 1rem;
        }

        .random-number.duplicate {
            background: var(--error);
            text-decoration: line-through;
        }

        /* Responsive */
        @media (max-width: 600px) {
            .container {
                padding: 12px;
            }

            header {
                padding: 16px;
            }

            header h1 {
                font-size: 1.2rem;
            }

            .stats-bar {
                flex-direction: column;
                gap: 8px;
            }

            .drill-card {
                padding: 20px;
            }

            .question-text {
                font-size: 1.1rem;
            }

            .answer-row {
                flex-direction: column;
            }

            .answer-input {
                width: 100%;
            }

            .btn {
                width: 100%;
            }

            .action-buttons {
                flex-direction: column;
            }

            .tab-btn {
                flex: 1;
                text-align: center;
                font-size: 0.8rem;
                padding: 8px 10px;
            }
        }

        /* Print Styles */
        @media print {
            .category-tabs, .action-buttons, .btn {
                display: none;
            }

            .expandable-content {
                display: block !important;
            }
        }

        /* QR Code Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.open {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 24px;
            border-radius: 12px;
            text-align: center;
            max-width: 320px;
            width: 90%;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .modal-content h3 {
            margin: 0 0 8px 0;
            color: var(--primary);
        }

        .modal-content p {
            margin: 0 0 16px 0;
            font-size: 0.9rem;
            color: var(--text-muted);
            word-break: break-all;
        }

        .qr-code {
            margin: 16px auto;
        }

        .qr-code svg {
            width: 200px;
            height: 200px;
        }

        .modal-close {
            margin-top: 16px;
            padding: 10px 24px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
        }

        .modal-close:hover {
            background: var(--primary-light);
        }

        /* QR Button in Header */
        .qr-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: background 0.2s;
        }

        .qr-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .header-row {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 12px;
        }

        /* Enhanced Mobile Touch Targets */
        @media (max-width: 600px) {
            .qr-btn {
                padding: 8px;
                font-size: 0;
            }

            .qr-btn svg {
                width: 20px;
                height: 20px;
            }

            .qr-btn span {
                display: none;
            }

            .keystroke-box {
                font-size: 0.85rem;
                padding: 10px 12px;
                overflow-x: auto;
            }

            .expandable-header {
                padding: 16px;
                min-height: 48px;
            }

            .modal-content {
                padding: 20px;
            }

            .qr-code svg {
                width: 180px;
                height: 180px;
            }
        }

        /* Prevent zoom on input focus (iOS) */
        @media (max-width: 600px) {
            .answer-input {
                font-size: 16px;
            }
        }

        /* ============================================
           EXPLAIN MODE - Stack Visualization
           ============================================ */

        .explain-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 16px;
            padding: 12px 16px;
            background: #f0f4f8;
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        .explain-toggle label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text);
        }

        .explain-toggle input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .explain-toggle .tooltip-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            background: var(--text-muted);
            color: white;
            border-radius: 50%;
            font-size: 0.75rem;
            font-weight: bold;
            cursor: help;
            margin-left: 4px;
        }

        .explain-toggle .tooltip-text {
            display: none;
            position: absolute;
            background: var(--primary);
            color: white;
            padding: 10px 14px;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: normal;
            max-width: 280px;
            line-height: 1.5;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .explain-toggle .tooltip-icon:hover + .tooltip-text,
        .explain-toggle .tooltip-text:hover {
            display: block;
        }

        /* Stack Widget */
        .stack-widget {
            display: none;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 10px;
            padding: 16px;
            margin-bottom: 16px;
            border: 2px solid #2d2d44;
        }

        .stack-widget.visible {
            display: block;
        }

        .stack-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .stack-title {
            color: #8892b0;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stack-controls {
            display: flex;
            gap: 8px;
        }

        .stack-btn {
            background: #2d2d44;
            border: 1px solid #444;
            color: #ccc;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .stack-btn:hover:not(:disabled) {
            background: #3d3d54;
            color: white;
        }

        .stack-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .stack-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        /* Horizontal Stack Display (mobile-friendly) */
        .stack-display {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        .stack-register {
            display: flex;
            align-items: center;
            gap: 6px;
            background: #252540;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #333;
            min-width: 80px;
        }

        .stack-register.highlight {
            border-color: var(--accent);
            box-shadow: 0 0 8px rgba(52, 152, 219, 0.4);
        }

        .stack-register.x-reg {
            background: #2e3a50;
            border-color: #4a5568;
        }

        .stack-label {
            color: #ffd700;
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 0.75rem;
            font-weight: bold;
            min-width: 14px;
        }

        .stack-value {
            color: #00ff88;
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 0.95rem;
            text-align: right;
            flex: 1;
        }

        .stack-value.empty {
            color: #555;
        }

        /* Memory Register (Sticky Note) */
        .memory-register {
            display: none;
            margin-left: auto;
            background: #fffacd;
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #e6d88a;
            box-shadow: 2px 2px 6px rgba(0,0,0,0.2);
            transform: rotate(1deg);
        }

        .memory-register.visible {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .memory-label {
            color: #666;
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 0.7rem;
        }

        .memory-value {
            color: #333;
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 0.9rem;
            font-weight: bold;
        }

        /* Expression Line */
        .expression-line {
            margin-top: 12px;
            padding: 10px 14px;
            background: #252540;
            border-radius: 6px;
            border: 1px solid #333;
        }

        .expression-label {
            color: #8892b0;
            font-size: 0.75rem;
            margin-bottom: 4px;
        }

        .expression-content {
            color: #e8e8e8;
            font-family: 'Times New Roman', serif;
            font-size: 1rem;
            font-style: italic;
        }

        /* Step Indicator */
        .step-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #8892b0;
            font-size: 0.85rem;
            margin-top: 10px;
        }

        .step-dots {
            display: flex;
            gap: 4px;
        }

        .step-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #444;
            cursor: pointer;
            transition: all 0.2s;
        }

        .step-dot:hover {
            background: #666;
        }

        .step-dot.active {
            background: var(--accent);
        }

        .step-dot.completed {
            background: var(--success);
        }

        /* Highlight current keystroke step */
        .keystroke-step.active-step .keystroke-box {
            border: 2px solid var(--accent);
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.3);
        }

        /* Why ENTER tooltip */
        .why-enter-tooltip {
            position: relative;
            display: inline-flex;
            align-items: center;
            margin-left: 4px;
        }

        .why-enter-btn {
            background: #4a4a6a;
            border: 1px solid #666;
            color: #ffd700;
            padding: 2px 6px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: bold;
        }

        .why-enter-btn:hover {
            background: #5a5a7a;
        }

        .why-enter-popup {
            display: none;
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--primary);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 0.8rem;
            width: 260px;
            line-height: 1.5;
            box-shadow: 0 4px 16px rgba(0,0,0,0.3);
            z-index: 50;
            margin-bottom: 8px;
        }

        .why-enter-popup::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 8px solid transparent;
            border-top-color: var(--primary);
        }

        .why-enter-btn:hover + .why-enter-popup,
        .why-enter-popup:hover {
            display: block;
        }

        /* Mobile adjustments for stack widget */
        @media (max-width: 600px) {
            .stack-display {
                flex-direction: column;
                align-items: stretch;
            }

            .stack-register {
                min-width: 100%;
            }

            .memory-register {
                margin-left: 0;
                margin-top: 8px;
            }

            .stack-controls {
                flex-wrap: wrap;
            }

            .why-enter-popup {
                width: 220px;
                left: 0;
                transform: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-row">
                <div>
                    <h1>DM42 Drill System</h1>
                    <div class="subtitle">Algebra 2 & AP Statistics - Unit 3</div>
                </div>
                <button class="qr-btn" onclick="toggleQRModal()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="3" width="7" height="7"></rect>
                        <rect x="14" y="3" width="7" height="7"></rect>
                        <rect x="3" y="14" width="7" height="7"></rect>
                        <rect x="14" y="14" width="3" height="3"></rect>
                        <rect x="18" y="14" width="3" height="3"></rect>
                        <rect x="14" y="18" width="3" height="3"></rect>
                        <rect x="18" y="18" width="3" height="3"></rect>
                    </svg>
                    <span>Share</span>
                </button>
            </div>
            <div class="stats-bar">
                <div class="stat">
                    Session: <span class="stat-value" id="session-correct">0</span>/<span id="session-total">0</span> correct
                </div>
                <div class="stat">
                    All-time: <span class="stat-value" id="alltime-correct">0</span> correct
                </div>
            </div>
        </header>

        <div class="category-tabs" id="category-tabs">
            <!-- Generated by JS -->
        </div>

        <div class="drill-card">
            <div class="category-title" id="category-title">Polynomial Evaluation (Horner's Method)</div>

            <div class="question-area">
                <div class="question-label">Question</div>
                <div class="question-text" id="question-text">Loading...</div>
            </div>

            <div class="answer-section" id="answer-section">
                <div class="answer-row">
                    <input type="text" class="answer-input" id="answer-input" placeholder="Enter your answer" autocomplete="off">
                    <button class="btn btn-success" id="verify-btn" onclick="markVerified()" style="display: none; background: #27ae60;">Mark Verified</button>
                    <button class="btn btn-primary" id="check-btn" onclick="checkAnswer()">Check Answer</button>
                </div>
                <div class="feedback" id="feedback"></div>
            </div>

            <div class="expandable" id="solution-section">
                <div class="expandable-header" onclick="toggleExpandable('solution-section')">
                    <span>Show Solution</span>
                    <span class="expandable-arrow">&#9660;</span>
                </div>
                <div class="expandable-content">
                    <div class="solution-text" id="solution-text"></div>
                </div>
            </div>

            <div class="expandable" id="keystroke-section">
                <div class="expandable-header" onclick="toggleExpandable('keystroke-section')">
                    <span>Show DM42 Keystrokes</span>
                    <span class="expandable-arrow">&#9660;</span>
                </div>
                <div class="expandable-content">
                    <!-- Explain Mode Toggle -->
                    <div class="explain-toggle">
                        <label>
                            <input type="checkbox" id="explain-mode-toggle" onchange="toggleExplainMode()">
                            Explain Mode
                            <span class="tooltip-icon">?</span>
                            <span class="tooltip-text">
                                <strong>What is RPN?</strong><br>
                                RPN uses a 4-level stack (T, Z, Y, X). Numbers go on the stack, then operations act on them. ENTER pushes X to Y and lifts the stack. This mode shows you what happens at each step.
                            </span>
                        </label>
                    </div>

                    <!-- Stack Visualization Widget -->
                    <div class="stack-widget" id="stack-widget">
                        <div class="stack-header">
                            <span class="stack-title">RPN Stack</span>
                            <div class="stack-controls">
                                <button class="stack-btn" id="prev-step-btn" onclick="prevStep()" disabled>
                                    &#9664; Prev
                                </button>
                                <button class="stack-btn" id="next-step-btn" onclick="nextStep()">
                                    Next &#9654;
                                </button>
                                <button class="stack-btn" id="play-btn" onclick="toggleAutoPlay()">
                                    &#9654; Play
                                </button>
                            </div>
                        </div>
                        <div class="stack-display">
                            <div class="stack-register">
                                <span class="stack-label">T</span>
                                <span class="stack-value empty" id="stack-t">-</span>
                            </div>
                            <div class="stack-register">
                                <span class="stack-label">Z</span>
                                <span class="stack-value empty" id="stack-z">-</span>
                            </div>
                            <div class="stack-register">
                                <span class="stack-label">Y</span>
                                <span class="stack-value empty" id="stack-y">-</span>
                            </div>
                            <div class="stack-register x-reg">
                                <span class="stack-label">X</span>
                                <span class="stack-value" id="stack-x">0</span>
                            </div>
                            <div class="memory-register" id="memory-register">
                                <span class="memory-label">R00:</span>
                                <span class="memory-value" id="memory-value">-</span>
                            </div>
                        </div>
                        <div class="expression-line">
                            <div class="expression-label">Current operation:</div>
                            <div class="expression-content" id="expression-content">Ready to begin...</div>
                        </div>
                        <div class="step-indicator">
                            <span>Step <span id="current-step">0</span> of <span id="total-steps">0</span></span>
                            <div class="step-dots" id="step-dots"></div>
                        </div>
                    </div>

                    <div id="keystroke-content"></div>
                </div>
            </div>

            <div class="action-buttons">
                <button class="btn btn-secondary" onclick="newQuestion()">New Question</button>
                <button class="btn btn-secondary" onclick="resetProgress()">Reset Progress</button>
            </div>
        </div>

        <div class="progress-card">
            <div class="progress-title">Category Progress</div>
            <div class="progress-grid" id="progress-grid">
                <!-- Generated by JS -->
            </div>
        </div>
    </div>

    <!-- QR Code Modal -->
    <div class="modal-overlay" id="qr-modal" onclick="toggleQRModal()">
        <div class="modal-content" onclick="event.stopPropagation()">
            <h3>Share This App</h3>
            <p>Scan to open on your device:</p>
            <div class="qr-code" id="qr-code"></div>
            <p style="font-size: 0.8rem; color: #666;">
                <a href="https://robjohncolson.github.io/dm42-drills" target="_blank" style="color: var(--accent);">
                    robjohncolson.github.io/dm42-drills
                </a>
            </p>
            <button class="modal-close" onclick="toggleQRModal()">Close</button>
        </div>
    </div>

    <script>
        // ============================================
        // DATA & STATE
        // ============================================

        const CATEGORIES = [
            { id: 'polynomial', name: 'Polynomial Eval', fullName: 'Polynomial Evaluation (Horner\'s Method)' },
            { id: 'binomial', name: 'Binomial Coeff', fullName: 'Binomial Coefficients' },
            { id: 'complex', name: 'Complex Roots', fullName: 'Complex Number Verification' },
            { id: 'factoring', name: 'Factoring', fullName: 'Factorization Verification' },
            { id: 'stratified', name: 'Stratified Sample', fullName: 'Stratified Sampling (AP Stats)' },
            { id: 'random', name: 'Random Integers', fullName: 'Random Integer Generation (AP Stats)' }
        ];

        let state = {
            currentCategory: 'polynomial',
            currentQuestion: null,
            sessionCorrect: 0,
            sessionTotal: 0,
            answered: false
        };

        // Explain Mode state
        let explainState = {
            enabled: false,
            currentStep: 0,
            totalSteps: 0,
            stackSnapshots: [],
            autoPlayInterval: null,
            isPlaying: false
        };

        let progress = loadProgress();

        function loadProgress() {
            try {
                const saved = localStorage.getItem('dm42_drill_progress');
                if (saved) {
                    return JSON.parse(saved);
                }
            } catch (e) {
                console.error('Error loading progress:', e);
            }
            return {
                polynomial: { attempted: 0, correct: 0 },
                binomial: { attempted: 0, correct: 0 },
                complex: { attempted: 0, correct: 0 },
                factoring: { attempted: 0, correct: 0 },
                stratified: { attempted: 0, correct: 0 },
                random: { attempted: 0, correct: 0 },
                lastSession: new Date().toISOString()
            };
        }

        function saveProgress() {
            try {
                progress.lastSession = new Date().toISOString();
                localStorage.setItem('dm42_drill_progress', JSON.stringify(progress));
            } catch (e) {
                console.error('Error saving progress:', e);
            }
        }

        // ============================================
        // UTILITY FUNCTIONS
        // ============================================

        function randInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function randChoice(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        function randNonZero(min, max) {
            let val = 0;
            while (val === 0) {
                val = randInt(min, max);
            }
            return val;
        }

        function factorial(n) {
            if (n <= 1) return 1;
            let result = 1;
            for (let i = 2; i <= n; i++) result *= i;
            return result;
        }

        function comb(n, k) {
            if (k > n || k < 0) return 0;
            return factorial(n) / (factorial(k) * factorial(n - k));
        }

        function formatCoeff(c, isFirst, varPart) {
            if (c === 0) return '';
            let sign = c > 0 ? (isFirst ? '' : ' + ') : (isFirst ? '-' : ' - ');
            let absC = Math.abs(c);
            if (varPart === '') {
                return sign + absC;
            }
            if (absC === 1) {
                return sign + varPart;
            }
            return sign + absC + varPart;
        }

        function formatPolynomial(coeffs) {
            // coeffs[0] is highest degree
            const degree = coeffs.length - 1;
            let parts = [];
            let isFirst = true;

            for (let i = 0; i <= degree; i++) {
                const c = coeffs[i];
                const power = degree - i;
                if (c === 0) continue;

                let varPart = '';
                if (power > 1) varPart = 'x<sup>' + power + '</sup>';
                else if (power === 1) varPart = 'x';

                parts.push(formatCoeff(c, isFirst, varPart));
                isFirst = false;
            }

            return parts.join('') || '0';
        }

        function formatNumber(n) {
            if (Number.isInteger(n)) return n.toString();
            return n.toFixed(4).replace(/\.?0+$/, '');
        }

        // ============================================
        // QUESTION GENERATORS
        // ============================================

        function generatePolynomialQuestion() {
            const degree = randInt(3, 5);
            const coeffs = [];

            // Leading coefficient non-zero
            coeffs.push(randNonZero(-5, 5));

            // Other coefficients can include zeros
            for (let i = 1; i <= degree; i++) {
                coeffs.push(randInt(-10, 10));
            }

            // Evaluation point
            let evalPoint = randInt(-5, 5);

            // Sometimes generate a root (answer = 0)
            if (Math.random() < 0.2) {
                // Adjust constant term to make evalPoint a root
                let sum = 0;
                for (let i = 0; i < degree; i++) {
                    sum = sum * evalPoint + coeffs[i];
                }
                coeffs[degree] = -sum * evalPoint;
                if (Math.abs(coeffs[degree]) > 100) {
                    // If too large, just use random
                    coeffs[degree] = randInt(-10, 10);
                }
            }

            // Calculate answer using Horner's method
            let answer = coeffs[0];
            for (let i = 1; i <= degree; i++) {
                answer = answer * evalPoint + coeffs[i];
            }

            // Generate Horner form string
            let hornerForm = '';
            for (let i = 0; i < degree; i++) {
                hornerForm = '(' + hornerForm + (i === 0 ? coeffs[0] : '') + ')x';
                const nextCoeff = coeffs[i + 1];
                if (nextCoeff >= 0) hornerForm += ' + ' + nextCoeff;
                else hornerForm += ' - ' + Math.abs(nextCoeff);
            }

            // Generate keystrokes and stack snapshots
            const { steps, snapshots } = generatePolynomialKeystrokes(coeffs, evalPoint);

            return {
                type: 'polynomial',
                question: `Evaluate P(x) = ${formatPolynomial(coeffs)} at x = ${evalPoint}`,
                answer: answer,
                tolerance: 0.0001,
                solution: generatePolynomialSolution(coeffs, evalPoint, answer),
                keystrokes: steps,
                stackSnapshots: snapshots
            };
        }

        function generatePolynomialSolution(coeffs, evalPoint, answer) {
            const degree = coeffs.length - 1;
            let html = '<div class="solution-step"><strong>Using Horner\'s Method:</strong></div>';
            html += '<div class="solution-step">Rewrite as nested form for efficient evaluation.</div>';

            let steps = [];
            let current = coeffs[0];
            steps.push(`Start: ${coeffs[0]}`);

            for (let i = 1; i <= degree; i++) {
                const prev = current;
                current = current * evalPoint + coeffs[i];
                const sign = coeffs[i] >= 0 ? '+' : '';
                steps.push(`${prev} × (${evalPoint}) ${sign} ${coeffs[i]} = ${current}`);
            }

            html += '<div class="solution-step">' + steps.join('<br>') + '</div>';
            html += `<div class="solution-answer">Answer: ${answer}</div>`;

            return html;
        }

        function generatePolynomialKeystrokes(coeffs, evalPoint) {
            const degree = coeffs.length - 1;
            let steps = [];
            let snapshots = [];

            // Initial stack state
            snapshots.push({
                T: null, Z: null, Y: null, X: 0,
                R00: null,
                expression: 'Stack empty, ready to begin Horner\'s method',
                keystrokeIndex: null
            });

            // Step 1: Store x value
            let storeKey = '';
            if (evalPoint < 0) {
                storeKey = `${Math.abs(evalPoint)} <span class="key">CHS</span> <span class="key">STO</span> <span class="key">00</span>`;
            } else {
                storeKey = `${evalPoint} <span class="key">STO</span> <span class="key">00</span>`;
            }
            steps.push({
                label: `Step 1: Store x = ${evalPoint} in register 00`,
                keys: storeKey
            });

            // Snapshot after storing x
            snapshots.push({
                T: null, Z: null, Y: null, X: evalPoint,
                R00: evalPoint,
                expression: `Stored x = ${evalPoint} in R00 for repeated use`,
                keystrokeIndex: 0
            });

            // Step 2: Enter leading coefficient
            let leadingEntry = coeffs[0] < 0 ?
                `${Math.abs(coeffs[0])} <span class="key">CHS</span> <span class="key key-enter">ENTER</span>` :
                `${coeffs[0]} <span class="key key-enter">ENTER</span>`;
            steps.push({
                label: 'Step 2: Enter leading coefficient',
                keys: leadingEntry
            });

            // Snapshot after entering leading coefficient
            snapshots.push({
                T: null, Z: null, Y: coeffs[0], X: coeffs[0],
                R00: evalPoint,
                expression: `Entered a<sub>${degree}</sub> = ${coeffs[0]} (ENTER duplicates to Y)`,
                keystrokeIndex: 1
            });

            // Steps for each subsequent coefficient
            let running = coeffs[0];
            for (let i = 1; i <= degree; i++) {
                const prevRunning = running;
                running = running * evalPoint + coeffs[i];
                const c = coeffs[i];
                let coeffPart = '';
                if (c >= 0) {
                    coeffPart = `${c} <span class="key">+</span>`;
                } else {
                    coeffPart = `${Math.abs(c)} <span class="key">CHS</span> <span class="key">+</span>`;
                }

                steps.push({
                    label: `Step ${i + 2}: Multiply by x and add coefficient`,
                    keys: `<span class="key">RCL</span> <span class="key">00</span> <span class="key">×</span> ${coeffPart}` +
                          `<span class="keystroke-comment">[Result: ${running}]</span>`
                });

                // Snapshot after RCL
                const afterRcl = prevRunning * evalPoint;
                snapshots.push({
                    T: null, Z: null, Y: prevRunning, X: evalPoint,
                    R00: evalPoint,
                    expression: `RCL 00: Recalled x = ${evalPoint} to X`,
                    keystrokeIndex: i + 1
                });

                // Snapshot after ×
                snapshots.push({
                    T: null, Z: null, Y: null, X: afterRcl,
                    R00: evalPoint,
                    expression: `× : ${prevRunning} × ${evalPoint} = ${afterRcl}`,
                    keystrokeIndex: i + 1
                });

                // Snapshot after adding coefficient
                snapshots.push({
                    T: null, Z: null, Y: null, X: running,
                    R00: evalPoint,
                    expression: `+ ${c}: ${afterRcl} + ${c} = ${running}`,
                    keystrokeIndex: i + 1
                });
            }

            // Final snapshot
            snapshots.push({
                T: null, Z: null, Y: null, X: running,
                R00: evalPoint,
                expression: `<strong>Final result: P(${evalPoint}) = ${running}</strong>`,
                keystrokeIndex: steps.length - 1
            });

            return { steps, snapshots };
        }

        function generateBinomialQuestion() {
            const n = randInt(4, 7);
            const a = randNonZero(-3, 3);
            const b = randNonZero(-3, 3);

            // Which term to ask for (0 to n, representing x^(n-k))
            const k = randInt(1, n - 1); // Avoid trivial cases
            const xPower = n - k;

            // Coefficient = C(n,k) * a^(n-k) * b^k
            const binomCoeff = comb(n, k);
            const aPower = Math.pow(a, n - k);
            const bPower = Math.pow(b, k);
            const answer = binomCoeff * aPower * bPower;

            const aStr = a === 1 ? 'x' : (a === -1 ? '-x' : `${a}x`);
            const bStr = b >= 0 ? ` + ${b}` : ` - ${Math.abs(b)}`;

            const question = `Find the coefficient of x<sup>${xPower}</sup> in the expansion of (${aStr}${bStr})<sup>${n}</sup>`;

            const { steps, snapshots } = generateBinomialKeystrokes(n, k, a, b);

            return {
                type: 'binomial',
                question: question,
                answer: answer,
                tolerance: 0.0001,
                solution: generateBinomialSolution(n, k, a, b, binomCoeff, aPower, bPower, answer, xPower),
                keystrokes: steps,
                stackSnapshots: snapshots
            };
        }

        function generateBinomialSolution(n, k, a, b, binomCoeff, aPower, bPower, answer, xPower) {
            let html = '<div class="solution-step"><strong>Binomial Theorem:</strong></div>';
            html += `<div class="solution-step">The x<sup>${xPower}</sup> term has k = ${k} (since power of x is n - k = ${n} - ${k} = ${xPower})</div>`;
            html += '<div class="solution-step">';
            html += `Coefficient = C(${n}, ${k}) × (${a})<sup>${n-k}</sup> × (${b})<sup>${k}</sup><br>`;
            html += `= ${binomCoeff} × ${aPower} × ${bPower}<br>`;
            html += `= ${binomCoeff * aPower} × ${bPower}<br>`;
            html += `= ${answer}`;
            html += '</div>';
            html += `<div class="solution-answer">Answer: ${answer}</div>`;
            return html;
        }

        function generateBinomialKeystrokes(n, k, a, b) {
            let steps = [];
            let snapshots = [];
            const combVal = comb(n, k);
            const aPow = n - k;
            const aResult = Math.pow(a, aPow);
            const bResult = Math.pow(b, k);
            const step2Result = combVal * aResult;
            const finalAnswer = step2Result * bResult;

            // Initial state
            snapshots.push({
                T: null, Z: null, Y: null, X: 0,
                R00: null,
                expression: 'Ready to calculate binomial coefficient term',
                keystrokeIndex: null
            });

            // Step 1: Calculate C(n,k)
            steps.push({
                label: `Step 1: Calculate C(${n}, ${k})`,
                keys: `${n} <span class="key key-enter">ENTER</span> ${k} <span class="key key-shift">[SHIFT]</span> <span class="key">[PROB]</span> <span class="key">COMB</span>` +
                      `<span class="keystroke-comment">[Result: ${combVal}]</span>`
            });

            // Snapshots for step 1
            snapshots.push({
                T: null, Z: null, Y: n, X: n,
                R00: null,
                expression: `Entered ${n}, ENTER duplicates to Y`,
                keystrokeIndex: 0
            });
            snapshots.push({
                T: null, Z: null, Y: n, X: k,
                R00: null,
                expression: `Entered ${k} (stack lift disabled after ENTER)`,
                keystrokeIndex: 0
            });
            snapshots.push({
                T: null, Z: null, Y: null, X: combVal,
                R00: null,
                expression: `COMB: C(${n},${k}) = ${combVal}`,
                keystrokeIndex: 0
            });

            // Step 2: Multiply by a^(n-k)
            let aEntry = a < 0 ? `${Math.abs(a)} <span class="key">CHS</span>` : `${a}`;
            steps.push({
                label: `Step 2: Multiply by (${a})<sup>${aPow}</sup>`,
                keys: `${aEntry} <span class="key key-enter">ENTER</span> ${aPow} <span class="key">y<sup>x</sup></span> <span class="key">×</span>` +
                      `<span class="keystroke-comment">[Result: ${step2Result}]</span>`
            });

            // Snapshots for step 2
            snapshots.push({
                T: null, Z: null, Y: combVal, X: a,
                R00: null,
                expression: `Entered base ${a}`,
                keystrokeIndex: 1
            });
            snapshots.push({
                T: null, Z: combVal, Y: a, X: a,
                R00: null,
                expression: `ENTER: Duplicated ${a} to Y, lifted stack`,
                keystrokeIndex: 1
            });
            snapshots.push({
                T: null, Z: combVal, Y: a, X: aPow,
                R00: null,
                expression: `Entered exponent ${aPow} (replaces X, lift disabled)`,
                keystrokeIndex: 1
            });
            snapshots.push({
                T: null, Z: null, Y: combVal, X: aResult,
                R00: null,
                expression: `y<sup>x</sup>: ${a}<sup>${aPow}</sup> = ${aResult}`,
                keystrokeIndex: 1
            });
            snapshots.push({
                T: null, Z: null, Y: null, X: step2Result,
                R00: null,
                expression: `×: ${combVal} × ${aResult} = ${step2Result}`,
                keystrokeIndex: 1
            });

            // Step 3: Multiply by b^k
            let bEntry = b < 0 ? `${Math.abs(b)} <span class="key">CHS</span>` : `${b}`;
            steps.push({
                label: `Step 3: Multiply by (${b})<sup>${k}</sup>`,
                keys: `${bEntry} <span class="key key-enter">ENTER</span> ${k} <span class="key">y<sup>x</sup></span> <span class="key">×</span>` +
                      `<span class="keystroke-comment">[Result: ${finalAnswer}]</span>`
            });

            // Snapshots for step 3
            snapshots.push({
                T: null, Z: null, Y: step2Result, X: b,
                R00: null,
                expression: `Entered base ${b}`,
                keystrokeIndex: 2
            });
            snapshots.push({
                T: null, Z: step2Result, Y: b, X: b,
                R00: null,
                expression: `ENTER: Duplicated ${b} to Y, lifted stack`,
                keystrokeIndex: 2
            });
            snapshots.push({
                T: null, Z: step2Result, Y: b, X: k,
                R00: null,
                expression: `Entered exponent ${k}`,
                keystrokeIndex: 2
            });
            snapshots.push({
                T: null, Z: null, Y: step2Result, X: bResult,
                R00: null,
                expression: `y<sup>x</sup>: ${b}<sup>${k}</sup> = ${bResult}`,
                keystrokeIndex: 2
            });
            snapshots.push({
                T: null, Z: null, Y: null, X: finalAnswer,
                R00: null,
                expression: `<strong>Final: ${step2Result} × ${bResult} = ${finalAnswer}</strong>`,
                keystrokeIndex: 2
            });

            return { steps, snapshots };
        }

        function generateComplexQuestion() {
            // Generate a nice complex root a + bi
            const a = randInt(-5, 5);
            const b = randNonZero(-5, 5); // b must be non-zero for complex

            // For x^2 + px + q = 0 with root a+bi:
            // p = -2a (sum of roots is a+bi + a-bi = 2a, so -p = 2a)
            // q = a^2 + b^2 (product of roots is (a+bi)(a-bi) = a^2 + b^2)
            const p = -2 * a;
            const q = a * a + b * b;

            const bSign = b >= 0 ? '+' : '-';
            const rootStr = `${a} ${bSign} ${Math.abs(b)}i`;

            let pStr = p >= 0 ? `+ ${p}x` : `- ${Math.abs(p)}x`;
            let qStr = `+ ${q}`;

            const question = `Verify that ${rootStr} is a root of x<sup>2</sup> ${pStr} ${qStr} = 0`;

            const { steps, snapshots } = generateComplexKeystrokes(a, b, p, q);

            return {
                type: 'complex',
                question: question,
                answer: 'verified', // Special handling for this type
                isVerification: true,
                complexRoot: { real: a, imag: b },
                coefficients: { p: p, q: q },
                solution: generateComplexSolution(a, b, p, q),
                keystrokes: steps,
                stackSnapshots: snapshots
            };
        }

        function generateComplexSolution(a, b, p, q) {
            // z^2 = (a+bi)^2 = a^2 - b^2 + 2abi
            const z2Real = a*a - b*b;
            const z2Imag = 2*a*b;

            // pz = p(a+bi) = pa + pbi
            const pzReal = p * a;
            const pzImag = p * b;

            // z^2 + pz = (z2Real + pzReal) + (z2Imag + pzImag)i
            const sumReal = z2Real + pzReal;
            const sumImag = z2Imag + pzImag;

            // z^2 + pz + q
            const finalReal = sumReal + q;
            const finalImag = sumImag;

            let html = '<div class="solution-step"><strong>Verify by substitution:</strong></div>';
            html += `<div class="solution-step">Let z = ${a} + ${b}i</div>`;
            html += `<div class="solution-step">`;
            html += `z<sup>2</sup> = (${a} + ${b}i)<sup>2</sup> = ${z2Real} + ${z2Imag}i<br>`;
            html += `${p}z = ${p}(${a} + ${b}i) = ${pzReal} + ${pzImag}i<br>`;
            html += `z<sup>2</sup> + ${p}z = (${z2Real} + ${pzReal}) + (${z2Imag} + ${pzImag})i = ${sumReal} + ${sumImag}i<br>`;
            html += `z<sup>2</sup> + ${p}z + ${q} = ${sumReal} + ${q} + ${sumImag}i = ${finalReal} + ${finalImag}i`;
            html += '</div>';
            html += `<div class="solution-answer">Result: 0 + 0i (Verified!)</div>`;

            return html;
        }

        function generateComplexKeystrokes(a, b, p, q) {
            let steps = [];
            let snapshots = [];

            const z = { real: a, imag: b };
            const z2Real = a*a - b*b;
            const z2Imag = 2*a*b;
            const pzReal = p * a;
            const pzImag = p * b;
            const afterPz = { real: z2Real + pzReal, imag: z2Imag + pzImag };

            // Initial state
            snapshots.push({
                T: null, Z: null, Y: null, X: 0,
                R00: null,
                expression: 'Ready to verify complex root',
                keystrokeIndex: null
            });

            // Step 1: Enter and store complex number
            let aEntry = a < 0 ? `${Math.abs(a)} <span class="key">CHS</span>` : `${a}`;
            let bEntry = b < 0 ? `${Math.abs(b)} <span class="key">CHS</span>` : `${b}`;

            steps.push({
                label: `Step 1: Enter z = ${a} + ${b}i and store in register 00`,
                keys: `${aEntry} <span class="key key-enter">ENTER</span> ${bEntry} <span class="key key-shift">[SHIFT]</span> <span class="key">[COMPLEX]</span> <span class="key">STO</span> <span class="key">00</span>`
            });

            // Snapshots for step 1
            snapshots.push({
                T: null, Z: null, Y: a, X: a,
                R00: null,
                expression: `Entered real part ${a}, ENTER duplicates`,
                keystrokeIndex: 0
            });
            snapshots.push({
                T: null, Z: null, Y: a, X: b,
                R00: null,
                expression: `Entered imaginary part ${b}`,
                keystrokeIndex: 0
            });
            snapshots.push({
                T: null, Z: null, Y: null, X: z,
                R00: null,
                expression: `COMPLEX: Combined into ${a}+${b}i`,
                keystrokeIndex: 0
            });
            snapshots.push({
                T: null, Z: null, Y: null, X: z,
                R00: z,
                expression: `STO 00: Stored z for reuse`,
                keystrokeIndex: 0
            });

            // Step 2: Calculate z^2
            steps.push({
                label: 'Step 2: Calculate z²',
                keys: `<span class="key">RCL</span> <span class="key">00</span> <span class="key key-enter">ENTER</span> <span class="key">×</span>` +
                      `<span class="keystroke-comment">[Result: ${z2Real} + ${z2Imag}i]</span>`
            });

            const z2 = { real: z2Real, imag: z2Imag };
            snapshots.push({
                T: null, Z: null, Y: z, X: z,
                R00: z,
                expression: `RCL 00 ENTER: z in both X and Y`,
                keystrokeIndex: 1
            });
            snapshots.push({
                T: null, Z: null, Y: null, X: z2,
                R00: z,
                expression: `×: z² = (${a}+${b}i)² = ${z2Real}+${z2Imag}i`,
                keystrokeIndex: 1
            });

            // Step 3: Add pz
            let pEntry = p < 0 ? `${Math.abs(p)} <span class="key">CHS</span>` : `${p}`;
            steps.push({
                label: `Step 3: Add ${p} × z`,
                keys: `<span class="key">RCL</span> <span class="key">00</span> ${pEntry} <span class="key">×</span> <span class="key">+</span>` +
                      `<span class="keystroke-comment">[Result: ${afterPz.real} + ${afterPz.imag}i]</span>`
            });

            const pz = { real: pzReal, imag: pzImag };
            snapshots.push({
                T: null, Z: null, Y: z2, X: z,
                R00: z,
                expression: `RCL 00: Recalled z`,
                keystrokeIndex: 2
            });
            snapshots.push({
                T: null, Z: null, Y: z2, X: pz,
                R00: z,
                expression: `× ${p}: ${p}z = ${pzReal}+${pzImag}i`,
                keystrokeIndex: 2
            });
            snapshots.push({
                T: null, Z: null, Y: null, X: afterPz,
                R00: z,
                expression: `+: z² + ${p}z = ${afterPz.real}+${afterPz.imag}i`,
                keystrokeIndex: 2
            });

            // Step 4: Add q
            steps.push({
                label: `Step 4: Add ${q}`,
                keys: `${q} <span class="key">+</span>` +
                      `<span class="keystroke-comment">[Result: 0 + 0i ✓]</span>`
            });

            snapshots.push({
                T: null, Z: null, Y: null, X: { real: 0, imag: 0 },
                R00: z,
                expression: `<strong>+ ${q}: Result = 0+0i (Verified!)</strong>`,
                keystrokeIndex: 3
            });

            return { steps, snapshots };
        }

        function generateFactoringQuestion() {
            const types = ['diffSquares', 'diffCubes', 'sumCubes'];
            const type = randChoice(types);

            let expression, factored, evalPoint, leftVal, rightVal;
            const x = randInt(-5, 5);
            evalPoint = x;

            if (type === 'diffSquares') {
                const a = randInt(2, 6);
                const b = randInt(1, 5);
                // a^2 x^2 - b^2 = (ax - b)(ax + b)
                expression = `${a*a}x<sup>2</sup> - ${b*b}`;
                factored = `(${a}x - ${b})(${a}x + ${b})`;
                leftVal = a*a*x*x - b*b;
                rightVal = (a*x - b) * (a*x + b);
            } else if (type === 'diffCubes') {
                const a = randInt(1, 4);
                const b = randInt(1, 3);
                // a^3 x^3 - b^3 = (ax - b)(a^2 x^2 + ab x + b^2)
                const a3 = a*a*a;
                const b3 = b*b*b;
                const a2 = a*a;
                const b2 = b*b;
                expression = `${a3}x<sup>3</sup> - ${b3}`;
                factored = `(${a}x - ${b})(${a2}x<sup>2</sup> + ${a*b}x + ${b2})`;
                leftVal = a3*x*x*x - b3;
                rightVal = (a*x - b) * (a2*x*x + a*b*x + b2);
            } else { // sumCubes
                const a = randInt(1, 4);
                const b = randInt(1, 3);
                const a3 = a*a*a;
                const b3 = b*b*b;
                const a2 = a*a;
                const b2 = b*b;
                expression = `${a3}x<sup>3</sup> + ${b3}`;
                factored = `(${a}x + ${b})(${a2}x<sup>2</sup> - ${a*b}x + ${b2})`;
                leftVal = a3*x*x*x + b3;
                rightVal = (a*x + b) * (a2*x*x - a*b*x + b2);
            }

            const question = `Verify: ${expression} = ${factored} by evaluating both sides at x = ${evalPoint}`;

            return {
                type: 'factoring',
                question: question,
                answer: leftVal,
                tolerance: 0.0001,
                isVerification: true,  // Show "Mark Verified" button for verification drills
                expectedBothSides: { left: leftVal, right: rightVal },
                solution: generateFactoringSolution(expression, factored, evalPoint, leftVal, rightVal),
                keystrokes: generateFactoringKeystrokes(expression, factored, evalPoint, leftVal)
            };
        }

        function generateFactoringSolution(expression, factored, x, leftVal, rightVal) {
            let html = '<div class="solution-step"><strong>Evaluate both sides at x = ' + x + ':</strong></div>';
            html += `<div class="solution-step">Left side: ${leftVal}</div>`;
            html += `<div class="solution-step">Right side: ${rightVal}</div>`;
            html += `<div class="solution-answer">${leftVal === rightVal ? 'Both sides equal! Verified.' : 'Values don\'t match - check calculation.'}</div>`;
            return html;
        }

        function generateFactoringKeystrokes(expression, factored, x, result) {
            let steps = [];
            let xEntry = x < 0 ? `${Math.abs(x)} <span class="key">CHS</span>` : `${x}`;

            steps.push({
                label: 'Step 1: Store x value',
                keys: `${xEntry} <span class="key">STO</span> <span class="key">00</span>`
            });

            steps.push({
                label: 'Step 2: Evaluate left side expression',
                keys: `<span class="keystroke-comment">[Substitute x = ${x} into ${expression.replace(/<[^>]*>/g, '')}]</span>`
            });

            steps.push({
                label: 'Step 3: Evaluate right side (factored form)',
                keys: `<span class="keystroke-comment">[Substitute x = ${x} into factored form]</span>`
            });

            steps.push({
                label: 'Step 4: Compare results',
                keys: `<span class="keystroke-comment">[Both should equal ${result}]</span>`
            });

            return steps;
        }

        function generateStratifiedQuestion() {
            const numStrata = randInt(2, 4);
            const groupNames = ['Group A', 'Group B', 'Group C', 'Group D'];
            const contextNames = [
                ['Freshmen', 'Sophomores', 'Juniors', 'Seniors'],
                ['Engineers', 'Managers', 'Executives', 'Interns'],
                ['Urban', 'Suburban', 'Rural', 'Metro'],
                ['Small', 'Medium', 'Large', 'Enterprise']
            ];

            const context = randChoice(contextNames).slice(0, numStrata);

            // Generate population sizes that will divide nicely
            const basePop = randInt(10, 50) * 10;
            const strata = [];
            let totalPop = 0;

            for (let i = 0; i < numStrata; i++) {
                const pop = basePop + randInt(-20, 30) * 10;
                strata.push({ name: context[i], pop: Math.max(50, pop) });
                totalPop += strata[i].pop;
            }

            // Choose sample size that gives nice numbers
            const sampleSize = randChoice([20, 25, 30, 40, 50]);

            // Calculate expected samples
            const samples = strata.map(s => ({
                name: s.name,
                pop: s.pop,
                sample: Math.round((s.pop / totalPop) * sampleSize * 100) / 100
            }));

            let questionText = `A population has:<br>`;
            samples.forEach(s => {
                questionText += `• ${s.name}: ${s.pop}<br>`;
            });
            questionText += `<br>Calculate stratified sample sizes for a total sample of n = ${sampleSize}.`;

            const { steps, snapshots } = generateStratifiedKeystrokes(samples, totalPop, sampleSize);

            return {
                type: 'stratified',
                question: questionText,
                answer: samples.map(s => s.sample),
                isMultiAnswer: true,
                strata: samples,
                totalPop: totalPop,
                sampleSize: sampleSize,
                solution: generateStratifiedSolution(samples, totalPop, sampleSize),
                keystrokes: steps,
                stackSnapshots: snapshots
            };
        }

        function generateStratifiedSolution(samples, totalPop, sampleSize) {
            let html = '<div class="solution-step"><strong>Proportional Allocation Formula:</strong></div>';
            html += '<div class="solution-step">n<sub>stratum</sub> = (Population<sub>stratum</sub> / Population<sub>total</sub>) × n</div>';
            html += '<div class="solution-step">';

            samples.forEach(s => {
                html += `${s.name}: (${s.pop} / ${totalPop}) × ${sampleSize} = ${s.sample.toFixed(2)}<br>`;
            });

            html += '</div>';
            html += '<div class="solution-answer">Answers: ' + samples.map(s => `${s.name}: ${s.sample.toFixed(1)}`).join(', ') + '</div>';

            return html;
        }

        function generateStratifiedKeystrokes(samples, totalPop, sampleSize) {
            let steps = [];
            let snapshots = [];

            // Initial state
            snapshots.push({
                T: null, Z: null, Y: null, X: 0,
                R00: null,
                expression: 'Ready to calculate stratified sample sizes',
                keystrokeIndex: null
            });

            samples.forEach((s, i) => {
                steps.push({
                    label: `Calculate sample for ${s.name}:`,
                    keys: `${s.pop} <span class="key key-enter">ENTER</span> ${totalPop} <span class="key">÷</span> ${sampleSize} <span class="key">×</span>` +
                          `<span class="keystroke-comment">[Result: ${s.sample.toFixed(2)}]</span>`
                });

                const proportion = s.pop / totalPop;

                // Snapshots for this stratum
                snapshots.push({
                    T: null, Z: null, Y: s.pop, X: s.pop,
                    R00: null,
                    expression: `Entered ${s.name} population: ${s.pop}`,
                    keystrokeIndex: i
                });
                snapshots.push({
                    T: null, Z: null, Y: s.pop, X: totalPop,
                    R00: null,
                    expression: `Entered total population: ${totalPop}`,
                    keystrokeIndex: i
                });
                snapshots.push({
                    T: null, Z: null, Y: null, X: proportion,
                    R00: null,
                    expression: `÷: ${s.pop}/${totalPop} = ${proportion.toFixed(4)} (proportion)`,
                    keystrokeIndex: i
                });
                snapshots.push({
                    T: null, Z: null, Y: null, X: s.sample,
                    R00: null,
                    expression: `× ${sampleSize}: Sample for ${s.name} = ${s.sample.toFixed(2)}`,
                    keystrokeIndex: i
                });
            });

            // Final summary
            snapshots.push({
                T: null, Z: null, Y: null, X: samples[samples.length - 1].sample,
                R00: null,
                expression: `<strong>Done! All ${samples.length} strata calculated.</strong>`,
                keystrokeIndex: steps.length - 1
            });

            return { steps, snapshots };
        }

        function generateRandomQuestion() {
            const N = randChoice([20, 30, 50, 100, 150, 200]);
            const n = randInt(3, 8);

            const question = `Generate ${n} random integers from 1 to ${N} for a simple random sample.<br><br>
                              <em>This is practice - use the keystroke sequence below, then enter any ${n} of your generated numbers separated by commas.</em>`;

            const { steps, snapshots } = generateRandomKeystrokes(N, n);

            return {
                type: 'random',
                question: question,
                answer: null, // No specific answer
                isPractice: true,
                N: N,
                n: n,
                solution: generateRandomSolution(N, n),
                keystrokes: steps,
                stackSnapshots: snapshots
            };
        }

        function generateRandomSolution(N, n) {
            let html = '<div class="solution-step"><strong>Random Integer Generation:</strong></div>';
            html += `<div class="solution-step">To generate a random integer from 1 to ${N}:</div>`;
            html += '<div class="solution-step">';
            html += `1. Enter ${N}<br>`;
            html += `2. Generate random number (0 ≤ x < 1)<br>`;
            html += `3. Multiply to scale to 0 ≤ x < ${N}<br>`;
            html += `4. Take integer part (0 to ${N-1})<br>`;
            html += `5. Add 1 to shift range to 1 to ${N}<br>`;
            html += `</div>`;
            html += `<div class="solution-step">Repeat ${n} times, skipping duplicates for sampling without replacement.</div>`;
            return html;
        }

        function generateRandomKeystrokes(N, n) {
            let steps = [{
                label: `Step 1: Store N = ${N} in register 00 (do once):`,
                keys: `${N} <span class="key">STO</span> <span class="key">00</span>`
            }, {
                label: `Step 2: Generate random integer 1 to ${N}:`,
                keys: `<span class="key">RCL</span> <span class="key">00</span> <span class="key key-shift">[SHIFT]</span> <span class="key">[PROB]</span> <span class="key">RAN</span> <span class="key">×</span> <span class="key key-shift">[SHIFT]</span> <span class="key">[PARTS]</span> <span class="key">IP</span> 1 <span class="key">+</span>`
            }, {
                label: 'To generate another:',
                keys: `<span class="keystroke-comment">Repeat Step 2. Skip duplicates when sampling without replacement.</span>`
            }, {
                label: 'Note:',
                keys: `<span class="keystroke-comment">Generate ${n} unique integers total.</span>`
            }];

            // Example random value for demonstration
            const exampleRandom = 0.42;
            const exampleScaled = N * exampleRandom;
            const exampleIP = Math.floor(exampleScaled);
            const exampleResult = exampleIP + 1;

            let snapshots = [
                {
                    T: null, Z: null, Y: null, X: 0,
                    R00: null,
                    expression: 'Ready to generate random integers',
                    keystrokeIndex: null
                },
                {
                    T: null, Z: null, Y: null, X: N,
                    R00: N,
                    expression: `STO 00: Stored N = ${N} for repeated use`,
                    keystrokeIndex: 0
                },
                {
                    T: null, Z: null, Y: null, X: N,
                    R00: N,
                    expression: `RCL 00: Recalled N = ${N}`,
                    keystrokeIndex: 1
                },
                {
                    T: null, Z: null, Y: N, X: exampleRandom,
                    R00: N,
                    expression: `RAN: Generated random 0 ≤ x < 1 (e.g., ${exampleRandom})`,
                    keystrokeIndex: 1
                },
                {
                    T: null, Z: null, Y: null, X: exampleScaled,
                    R00: N,
                    expression: `×: ${N} × ${exampleRandom} = ${exampleScaled.toFixed(2)} (scaled to 0..${N})`,
                    keystrokeIndex: 1
                },
                {
                    T: null, Z: null, Y: null, X: exampleIP,
                    R00: N,
                    expression: `IP: Integer part = ${exampleIP} (range 0..${N-1})`,
                    keystrokeIndex: 1
                },
                {
                    T: null, Z: null, Y: null, X: exampleResult,
                    R00: N,
                    expression: `<strong>+ 1: Final result = ${exampleResult} (range 1..${N})</strong>`,
                    keystrokeIndex: 1
                }
            ];

            return { steps, snapshots };
        }

        // ============================================
        // QUESTION DISPATCH
        // ============================================

        function generateQuestion(category) {
            switch (category) {
                case 'polynomial': return generatePolynomialQuestion();
                case 'binomial': return generateBinomialQuestion();
                case 'complex': return generateComplexQuestion();
                case 'factoring': return generateFactoringQuestion();
                case 'stratified': return generateStratifiedQuestion();
                case 'random': return generateRandomQuestion();
                default: return generatePolynomialQuestion();
            }
        }

        // ============================================
        // UI FUNCTIONS
        // ============================================

        function renderCategoryTabs() {
            const container = document.getElementById('category-tabs');
            container.innerHTML = '';

            CATEGORIES.forEach(cat => {
                const btn = document.createElement('button');
                btn.className = 'tab-btn' + (cat.id === state.currentCategory ? ' active' : '');
                btn.onclick = () => selectCategory(cat.id);

                const prog = progress[cat.id];
                const progressText = prog.attempted > 0 ? ` (${prog.correct}/${prog.attempted})` : '';

                btn.innerHTML = cat.name + `<span class="tab-progress">${progressText}</span>`;
                container.appendChild(btn);
            });
        }

        function selectCategory(categoryId) {
            state.currentCategory = categoryId;
            renderCategoryTabs();
            newQuestion();
        }

        function renderQuestion() {
            const q = state.currentQuestion;
            if (!q) return;

            const cat = CATEGORIES.find(c => c.id === state.currentCategory);
            document.getElementById('category-title').textContent = cat.fullName;
            document.getElementById('question-text').innerHTML = q.question;
            document.getElementById('solution-text').innerHTML = q.solution;

            // Render keystrokes
            const keystrokeContainer = document.getElementById('keystroke-content');
            keystrokeContainer.innerHTML = '';

            q.keystrokes.forEach(step => {
                const stepDiv = document.createElement('div');
                stepDiv.className = 'keystroke-step';
                stepDiv.innerHTML = `
                    <div class="step-label">${step.label}</div>
                    <div class="keystroke-box">${step.keys}</div>
                `;
                keystrokeContainer.appendChild(stepDiv);
            });

            // Reset answer section
            const answerInput = document.getElementById('answer-input');
            answerInput.value = '';
            answerInput.className = 'answer-input';
            answerInput.disabled = false;
            document.getElementById('feedback').className = 'feedback';
            document.getElementById('feedback').textContent = '';

            // Collapse expandables
            document.getElementById('solution-section').classList.remove('open');
            document.getElementById('keystroke-section').classList.remove('open');

            // Reset explain mode if active
            if (explainState.enabled) {
                stopAutoPlay();
                initializeExplainMode();
            }

            // Handle special question types and show/hide verify button
            const verifyBtn = document.getElementById('verify-btn');
            if (q.isPractice) {
                answerInput.placeholder = 'Enter your generated numbers (comma-separated)';
                verifyBtn.style.display = 'none';
            } else if (q.isVerification) {
                answerInput.placeholder = 'Or type "0+0i" / result manually';
                verifyBtn.style.display = 'inline-block';
            } else if (q.isMultiAnswer) {
                answerInput.placeholder = 'Enter answers separated by commas';
                verifyBtn.style.display = 'none';
            } else {
                answerInput.placeholder = 'Enter your answer';
                verifyBtn.style.display = 'none';
            }

            state.answered = false;
        }

        function markVerified() {
            // For verification drills, user clicks this after confirming result on calculator
            document.getElementById('answer-input').value = 'verified';
            checkAnswer();
        }

        function checkAnswer() {
            if (state.answered) return;

            const q = state.currentQuestion;
            const input = document.getElementById('answer-input');
            const feedback = document.getElementById('feedback');
            const userAnswer = input.value.trim();

            if (!userAnswer) {
                feedback.textContent = 'Please enter an answer.';
                feedback.className = 'feedback incorrect';
                return;
            }

            let isCorrect = false;

            if (q.isPractice) {
                // Practice mode - always accept
                isCorrect = true;
                feedback.textContent = 'Great practice! Check your work against the solution.';
            } else if (q.isVerification) {
                // Verification drills - accept "verified" button click or typed confirmation
                const lower = userAnswer.toLowerCase().replace(/\s+/g, '');

                // Always accept "verified" (from Mark Verified button)
                if (lower === 'verified') {
                    isCorrect = true;
                } else if (q.type === 'complex') {
                    // Complex root verification: accept 0, 0+0i, etc.
                    const validPatterns = [
                        /^0$/,
                        /^0\.?0*$/,
                        /^0\.?0*\+0\.?0*i$/,
                        /^0\.?0*i?0\.?0*$/,
                        /^0\+0i$/,
                        /^0i$/
                    ];
                    isCorrect = validPatterns.some(pattern => pattern.test(lower));
                } else if (q.type === 'factoring') {
                    // Factoring verification: also accept the numerical answer
                    const userNum = parseFloat(userAnswer);
                    if (!isNaN(userNum)) {
                        isCorrect = Math.abs(userNum - q.answer) < (q.tolerance || 0.0001);
                    }
                }
            } else if (q.isMultiAnswer) {
                // Multiple answers (stratified sampling)
                const userParts = userAnswer.split(',').map(s => parseFloat(s.trim()));
                const expected = q.answer;
                if (userParts.length === expected.length) {
                    isCorrect = userParts.every((val, i) =>
                        Math.abs(val - expected[i]) < 0.5 // Allow rounding
                    );
                }
            } else {
                // Standard numerical answer
                const userNum = parseFloat(userAnswer);
                if (!isNaN(userNum)) {
                    isCorrect = Math.abs(userNum - q.answer) < (q.tolerance || 0.0001);
                }
            }

            state.answered = true;
            state.sessionTotal++;
            progress[state.currentCategory].attempted++;

            if (isCorrect) {
                state.sessionCorrect++;
                progress[state.currentCategory].correct++;
                input.className = 'answer-input correct';
                feedback.textContent = 'Correct!';
                feedback.className = 'feedback correct';
            } else {
                input.className = 'answer-input incorrect';
                if (q.isPractice) {
                    feedback.textContent = 'Check the solution to verify your work.';
                } else if (q.isMultiAnswer) {
                    const expected = q.answer.map(a => a.toFixed(1)).join(', ');
                    feedback.textContent = `Expected: ${expected}. Check your calculations.`;
                } else {
                    feedback.textContent = `Not quite. The answer is ${q.answer}. Try the next one!`;
                }
                feedback.className = 'feedback incorrect';
            }

            // Auto-expand solution on incorrect
            if (!isCorrect) {
                document.getElementById('solution-section').classList.add('open');
            }

            saveProgress();
            updateStats();
            renderProgressGrid();
            renderCategoryTabs();
        }

        function newQuestion() {
            state.currentQuestion = generateQuestion(state.currentCategory);
            renderQuestion();
        }

        function toggleExpandable(id) {
            document.getElementById(id).classList.toggle('open');
        }

        function updateStats() {
            document.getElementById('session-correct').textContent = state.sessionCorrect;
            document.getElementById('session-total').textContent = state.sessionTotal;

            let allTimeCorrect = 0;
            for (const cat of CATEGORIES) {
                allTimeCorrect += progress[cat.id].correct;
            }
            document.getElementById('alltime-correct').textContent = allTimeCorrect;
        }

        function renderProgressGrid() {
            const grid = document.getElementById('progress-grid');
            grid.innerHTML = '';

            CATEGORIES.forEach(cat => {
                const prog = progress[cat.id];
                const pct = prog.attempted > 0 ? Math.round((prog.correct / prog.attempted) * 100) : 0;

                const item = document.createElement('div');
                item.className = 'progress-item';
                item.innerHTML = `
                    <div class="progress-item-label">${cat.name}</div>
                    <div class="progress-item-value">${prog.correct}/${prog.attempted}</div>
                    <div class="progress-bar-container">
                        <div class="progress-bar" style="width: ${pct}%"></div>
                    </div>
                `;
                grid.appendChild(item);
            });
        }

        function resetProgress() {
            if (confirm('Reset all progress? This cannot be undone.')) {
                progress = {
                    polynomial: { attempted: 0, correct: 0 },
                    binomial: { attempted: 0, correct: 0 },
                    complex: { attempted: 0, correct: 0 },
                    factoring: { attempted: 0, correct: 0 },
                    stratified: { attempted: 0, correct: 0 },
                    random: { attempted: 0, correct: 0 },
                    lastSession: new Date().toISOString()
                };
                state.sessionCorrect = 0;
                state.sessionTotal = 0;
                saveProgress();
                updateStats();
                renderProgressGrid();
                renderCategoryTabs();
            }
        }

        // ============================================
        // EXPLAIN MODE FUNCTIONS
        // ============================================

        function toggleExplainMode() {
            explainState.enabled = document.getElementById('explain-mode-toggle').checked;
            const widget = document.getElementById('stack-widget');

            if (explainState.enabled) {
                widget.classList.add('visible');
                initializeExplainMode();
            } else {
                widget.classList.remove('visible');
                stopAutoPlay();
                clearStepHighlights();
            }
        }

        function initializeExplainMode() {
            const q = state.currentQuestion;
            if (!q || !q.stackSnapshots) {
                // No snapshots available for this question type
                document.getElementById('expression-content').textContent = 'Stack visualization not available for this drill type.';
                return;
            }

            explainState.stackSnapshots = q.stackSnapshots;
            explainState.totalSteps = q.stackSnapshots.length;
            explainState.currentStep = 0;

            // Update total steps display
            document.getElementById('total-steps').textContent = explainState.totalSteps;

            // Create step dots
            const dotsContainer = document.getElementById('step-dots');
            dotsContainer.innerHTML = '';
            for (let i = 0; i < explainState.totalSteps; i++) {
                const dot = document.createElement('span');
                dot.className = 'step-dot';
                dot.onclick = () => goToStep(i);
                dotsContainer.appendChild(dot);
            }

            // Show initial state
            updateStackDisplay();
            updateStepButtons();
        }

        function updateStackDisplay() {
            if (explainState.currentStep >= explainState.stackSnapshots.length) return;

            const snapshot = explainState.stackSnapshots[explainState.currentStep];

            // Update stack registers
            updateRegister('stack-t', snapshot.T);
            updateRegister('stack-z', snapshot.Z);
            updateRegister('stack-y', snapshot.Y);
            updateRegister('stack-x', snapshot.X);

            // Update memory register
            const memReg = document.getElementById('memory-register');
            const memVal = document.getElementById('memory-value');
            if (snapshot.R00 !== undefined && snapshot.R00 !== null) {
                memReg.classList.add('visible');
                memVal.textContent = formatStackValue(snapshot.R00);
            } else {
                memReg.classList.remove('visible');
            }

            // Update expression line
            document.getElementById('expression-content').innerHTML = snapshot.expression || '';

            // Update step counter
            document.getElementById('current-step').textContent = explainState.currentStep + 1;

            // Update step dots
            const dots = document.querySelectorAll('.step-dot');
            dots.forEach((dot, i) => {
                dot.classList.remove('active', 'completed');
                if (i < explainState.currentStep) {
                    dot.classList.add('completed');
                } else if (i === explainState.currentStep) {
                    dot.classList.add('active');
                }
            });

            // Highlight corresponding keystroke step
            highlightKeystrokeStep(snapshot.keystrokeIndex);
        }

        function updateRegister(id, value) {
            const elem = document.getElementById(id);
            if (value === undefined || value === null || value === '') {
                elem.textContent = '-';
                elem.classList.add('empty');
            } else {
                elem.textContent = formatStackValue(value);
                elem.classList.remove('empty');
            }
        }

        function formatStackValue(val) {
            if (val === null || val === undefined) return '-';
            if (typeof val === 'object' && 'real' in val && 'imag' in val) {
                // Complex number
                const sign = val.imag >= 0 ? '+' : '';
                return `${val.real}${sign}${val.imag}i`;
            }
            if (typeof val === 'number') {
                if (Number.isInteger(val)) return val.toString();
                return val.toFixed(4).replace(/\.?0+$/, '');
            }
            return String(val);
        }

        function highlightKeystrokeStep(index) {
            clearStepHighlights();
            if (index === undefined || index === null) return;

            const steps = document.querySelectorAll('.keystroke-step');
            if (steps[index]) {
                steps[index].classList.add('active-step');
                steps[index].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        function clearStepHighlights() {
            document.querySelectorAll('.keystroke-step.active-step').forEach(el => {
                el.classList.remove('active-step');
            });
        }

        function updateStepButtons() {
            document.getElementById('prev-step-btn').disabled = explainState.currentStep === 0;
            document.getElementById('next-step-btn').disabled = explainState.currentStep >= explainState.totalSteps - 1;
        }

        function nextStep() {
            if (explainState.currentStep < explainState.totalSteps - 1) {
                explainState.currentStep++;
                updateStackDisplay();
                updateStepButtons();
            } else {
                stopAutoPlay();
            }
        }

        function prevStep() {
            if (explainState.currentStep > 0) {
                explainState.currentStep--;
                updateStackDisplay();
                updateStepButtons();
            }
        }

        function goToStep(index) {
            explainState.currentStep = index;
            updateStackDisplay();
            updateStepButtons();
        }

        function toggleAutoPlay() {
            if (explainState.isPlaying) {
                stopAutoPlay();
            } else {
                startAutoPlay();
            }
        }

        function startAutoPlay() {
            if (explainState.currentStep >= explainState.totalSteps - 1) {
                explainState.currentStep = 0;
                updateStackDisplay();
            }

            explainState.isPlaying = true;
            document.getElementById('play-btn').innerHTML = '&#9632; Stop';
            document.getElementById('play-btn').classList.add('active');

            explainState.autoPlayInterval = setInterval(() => {
                if (explainState.currentStep < explainState.totalSteps - 1) {
                    nextStep();
                } else {
                    stopAutoPlay();
                }
            }, 1500);
        }

        function stopAutoPlay() {
            explainState.isPlaying = false;
            document.getElementById('play-btn').innerHTML = '&#9654; Play';
            document.getElementById('play-btn').classList.remove('active');

            if (explainState.autoPlayInterval) {
                clearInterval(explainState.autoPlayInterval);
                explainState.autoPlayInterval = null;
            }
        }

        // ============================================
        // KEYBOARD SUPPORT
        // ============================================

        document.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && document.activeElement.id === 'answer-input') {
                if (!state.answered) {
                    checkAnswer();
                } else {
                    newQuestion();
                }
            }
        });

        // ============================================
        // QR CODE MODAL
        // ============================================

        function toggleQRModal() {
            const modal = document.getElementById('qr-modal');
            modal.classList.toggle('open');

            // Generate QR code on first open
            if (modal.classList.contains('open') && !document.getElementById('qr-code').hasChildNodes()) {
                generateQRCode('https://robjohncolson.github.io/dm42-drills');
            }
        }

        // Minimal QR Code Generator (for URL encoding)
        function generateQRCode(text) {
            const container = document.getElementById('qr-code');

            // Use a simple approach: create an image from a QR API for reliability
            // This works when online; falls back to the text link when offline
            const img = document.createElement('img');
            img.src = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(text)}`;
            img.alt = 'QR Code';
            img.style.width = '200px';
            img.style.height = '200px';
            img.style.borderRadius = '8px';

            // Fallback for offline: show a styled link box
            img.onerror = function() {
                container.innerHTML = `
                    <div style="width: 200px; height: 200px; background: #f0f0f0; border-radius: 8px;
                                display: flex; align-items: center; justify-content: center;
                                flex-direction: column; padding: 20px; box-sizing: border-box;">
                        <svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="2">
                            <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
                            <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
                        </svg>
                        <span style="margin-top: 10px; font-size: 0.8rem; color: #666; text-align: center;">
                            Use the link below
                        </span>
                    </div>
                `;
            };

            container.appendChild(img);
        }

        // Close modal with Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const modal = document.getElementById('qr-modal');
                if (modal.classList.contains('open')) {
                    toggleQRModal();
                }
            }
        });

        // ============================================
        // INITIALIZATION
        // ============================================

        function init() {
            renderCategoryTabs();
            renderProgressGrid();
            updateStats();
            newQuestion();
        }

        init();
    </script>
</body>
</html>
